##Backtest
import backtrader as bt
import yfinance as yf
from datetime import datetime, timedelta
import pandas as pd
from concurrent.futures import ThreadPoolExecutor, as_completed
import talib

# Define the Backtrader Strategy
class CustomStrategy(bt.Strategy):
    params = (
        ('market_cap_threshold', 300000000),
        ('volume_threshold', 500000),
        ('adx_threshold', 35),
        ('rsi_threshold', 50),
        ('holding_period', 5),  # Holding period of 5 days
    )

    def __init__(self):
        self.data0 = self.datas[0]
        self.buy_dates = {}

        # Perform Trending Sector Analysis at the start
        etf_symbols = ['XLY', 'XLP', 'XLE', 'XLF', 'XLV', 'XLI', 'XLK', 'XLB', 'XLRE', 'XLU', 'XLC']
        etf_start_date = datetime.now() - timedelta(days=90)
        etf_end_date = datetime.now()

        # Fetch ETF data
        etf_data = {symbol: yf.Ticker(symbol).history(start=etf_start_date, end=etf_end_date)['Close'] for symbol in etf_symbols}
        etf_df = pd.DataFrame(etf_data)
        etf_returns = (etf_df.iloc[-1] / etf_df.iloc[0] - 1) * 100
        top_3_etfs = etf_returns.sort_values(ascending=False).head(3)
        etf_to_sector = {
            'XLY': 'Consumer Cyclical', 'XLP': 'Consumer Defensive', 'XLE': 'Energy',
            'XLF': 'Financial Services', 'XLV': 'Healthcare', 'XLI': 'Industrials',
            'XLK': 'Technology', 'XLB': 'Basic Materials', 'XLRE': 'Real Estate',
            'XLU': 'Utilities', 'XLC': 'Communication Services'
        }
        self.top_sectors = [etf_to_sector[etf] for etf in top_3_etfs.index if etf in etf_to_sector]
        print("Top sectors based on ETF performance:", self.top_sectors)

    def next(self):
        current_date = self.datas[0].datetime.date(0)
        # Check for positions to close
        for position in list(self.buy_dates.keys()):
            if (current_date - self.buy_dates[position]).days >= self.params.holding_period:
                self.close(data=self.getdatabyname(position))
                del self.buy_dates[position]

        # Fetch yesterday's data for filtration
        yesterday = current_date - timedelta(days=1)
        if yesterday.weekday() == 5:  # Saturday
            yesterday = yesterday - timedelta(days=1)
        elif yesterday.weekday() == 6:  # Sunday
            yesterday = yesterday - timedelta(days=2)

        filtered_tickers = self.filter_stocks(yesterday)

        for ticker in filtered_tickers:
            data = self.getdatabyname(ticker)
            if data and not self.getposition(data).size:
                self.buy(data=data)
                self.buy_dates[ticker] = current_date

    def filter_stocks(self, date):
        filtered_tickers = []
        tickers = tickers_df['symbol'].tolist()

        def fetch_data(ticker):
            try:
                stock = yf.Ticker(ticker)
                hist = stock.history(start=(date - timedelta(days=50)).strftime('%Y-%m-%d'), end=date.strftime('%Y-%m-%d'))
                if not hist.empty and len(hist) >= 35:
                    hist['symbol'] = ticker
                    hist['marketCap'] = stock.info.get('marketCap', 'N/A')
                    hist['sector'] = stock.info.get('sector', 'N/A')
                    hist['averageVolume10days'] = stock.info.get('averageVolume10days', 'N/A')
                    hist['ADX'] = talib.ADX(hist['High'], hist['Low'], hist['Close'], timeperiod=14)
                    hist['RSI'] = talib.RSI(hist['Close'], timeperiod=14)
                    last_day_data = hist.iloc[-1]
                    return last_day_data
                else:
                    return None
            except Exception as e:
                print(f"Error processing ticker {ticker}: {e}")
                return None

        # Parallel processing to fetch data
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(fetch_data, ticker): ticker for ticker in tickers}
            for future in as_completed(futures):
                result = future.result()
                if result is not None:
                    if (result['marketCap'] > self.params.market_cap_threshold and
                            result['averageVolume10days'] > self.params.volume_threshold and
                            result['sector'] in self.top_sectors and
                            result['ADX'] > self.params.adx_threshold and
                            result['RSI'] > self.params.rsi_threshold):
                        filtered_tickers.append(result['symbol'])
        
        return filtered_tickers

def fetch_backtest_data(tickers, start, end):
    data_list = []
    valid_tickers = [ticker for ticker in tickers if isinstance(ticker, str) and ticker.strip()]
    
    for ticker in valid_tickers:
        try:
            df = yf.download(ticker, start=start, end=end)
            if not df.empty:
                df['ticker'] = ticker
                data_list.append(bt.feeds.PandasData(dataname=df))
        except Exception as e:
            print(f"Error fetching data for {ticker}: {e}")
    return data_list

# Load the ticker list from the provided CSV file
file_path = '/Users/ryangalitzdorfer/Downloads/Market Machine/Stock Filtration/Merged_Stocks.csv'
tickers_df = pd.read_csv(file_path)

# Define the start date and end date for the backtest
start_date = datetime(2023, 2, 1)
end_date = datetime(2023, 5, 1)

# Initialize Cerebro
cerebro = bt.Cerebro()

# Add strategy to Cerebro
cerebro.addstrategy(CustomStrategy)

# Fetch data and add to Cerebro
data_feeds = fetch_backtest_data(tickers_df['symbol'].tolist(), start_date, end_date)
for data in data_feeds:
    cerebro.adddata(data)

# Set initial cash
cerebro.broker.set_cash(1000000.0)

# Set commission
cerebro.broker.setcommission(commission=0.001)

# Print starting portfolio value
print(f"Starting Portfolio Value: {cerebro.broker.getvalue():.2f}")

# Run the backtest
cerebro.run()

# Print final portfolio value
print(f"Final Portfolio Value: {cerebro.broker.getvalue():.2f}")

# Plot the results
cerebro.plot()












































